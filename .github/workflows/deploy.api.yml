name: Deploy Workflow With Integration Test

on:
  push:
    branches: [main]
    paths:
      - 'apps/api/**'
  workflow_dispatch:

jobs:
  test-and-build:
    name: Build, test
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create temp .env from secret (base64)
        env:
          ENV_B64: ${{ secrets.ENV_B64 }}
        run: |
          set -e
          if [ -z "$ENV_B64" ]; then echo "ENV_B64 empty"; exit 1; fi
          echo "$ENV_B64" | base64 --decode > ./.env.dev
          chmod 600 ./.env.dev

      - name: Start docker-compose for integration tests and stop when api exits
        env:
          IMAGE_NAME: ${{ secrets.DOCKER_HUB_IMAGE_NAME }}
          SERVICE_NAME: ${{ vars.SERVICE_NAME}}
          COMPOSE_FILE_DEV: ${{ vars.COMPOSE_FILE_DEV}}
        run: |
          docker build -t "$IMAGE_NAME" -f apps/api/Dockerfile .
          docker compose -f $COMPOSE_FILE_DEV up -d
          chmod +x ./scripts/wait-for-api.sh
          SLEEP_INTERVAL=1 MAX_RETRIES=10 STACK_FILE=$COMPOSE_FILE_DEV SERVICE_NAME=$SERVICE_NAME ./scripts/wait-for-api.sh --down

      - name: Login to Docker Hub
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
        run: |
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin

      - name: Push to Registry
        env:
          IMAGE_NAME: ${{ secrets.DOCKER_HUB_IMAGE_NAME }}
        run: |
          docker push "$IMAGE_NAME"

      - name: Logout Docker Hub
        run: docker logout

      - name: Remove .env
        if: always()
        run: |
          rm -f ./.env.dev || true

  deploy-on-server:
    runs-on: [self-hosted, prod-runner]
    needs: [test-and-build]
    steps:
      - name: Checkout only docker-compose.prod.yml
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            apps/api/docker-compose.prod.yml
          sparse-checkout-cone-mode: false

      - name: Show the file
        env:
          COMPOSE_FILE_PROD: ${{ vars.COMPOSE_FILE_PROD }}
        run: |
          echo "File exists:"
          ls -la $COMPOSE_FILE_PROD
          sed -n '1,200p' $COMPOSE_FILE_PROD

      - name: Copy environment file to server folder
        env:
          ENV_PROD_B64: ${{ secrets.ENV_PROD_B64 }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          set -e
          cd ~
          mkdir -p ./$TARGET_DIR
          if [ -z "$ENV_PROD_B64" ]; then
            echo "ENV_PROD_B64 is empty"
            exit 1
          fi
          echo "$ENV_PROD_B64" | base64 --decode > ~/$TARGET_DIR/.env
          chmod 600 ~/$TARGET_DIR/.env
          echo ".env created in $TARGET_DIR"

      - name: Copy compose into target dir
        env:
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          COMPOSE_FILE_PROD: ${{ vars.COMPOSE_FILE_PROD }}
        run: |
          cd ~
          mkdir -p ./$TARGET_DIR
          # copy and rename to docker-compose.prod.yml in target dir
          cp $COMPOSE_FILE_PROD ./$TARGET_DIR/docker-compose.yml
          ls -la ./$TARGET_DIR
          sed -n '1,200p' ./$TARGET_DIR/docker-compose.yml

      - name: Pull Image and Run Compose (only recreate service)
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
          IMAGE_NAME: ${{ secrets.DOCKER_HUB_IMAGE_NAME }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          SERVICE_NAME: ${{ vars.SERVICE_NAME}}
        run: |
          set -e
          cd ~
          cd ./$TARGET_DIR
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin
          docker pull "$IMAGE_NAME"
          docker logout
          docker compose -f docker-compose.yml up -d
