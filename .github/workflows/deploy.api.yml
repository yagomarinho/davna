name: Deploy Workflow With Integration Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  watch:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.paths.outputs.api }}
      ffmpeg: ${{ steps.paths.outputs.ffmpeg }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed paths
        id: paths
        uses: dorny/paths-filter@v2
        with:
          filters: |
            api:
              - 'apps/api/**'
            ffmpeg:
              - 'apps/ffmpeg/**'

  ffmpeg-build:
    name: Build, test
    runs-on: ubuntu-latest
    needs: watch
    if: ${{ needs.watch.outputs.ffmpeg == 'true' }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build ffmpeg api
        env:
          FFMPEG_IMAGE_NAME: ${{ secrets.DOCKER_HUB_FFMPEG_IMAGE_NAME }}
        run: |
          docker build -t "$FFMPEG_IMAGE_NAME" -f apps/ffmpeg/Dockerfile .

      - name: Login to Docker Hub
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
        run: |
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin

      - name: Push to Registry
        env:
          FFMPEG_IMAGE_NAME: ${{ secrets.DOCKER_HUB_FFMPEG_IMAGE_NAME }}
        run: |
          docker push "$FFMPEG_IMAGE_NAME"

      - name: Logout Docker Hub
        run: docker logout

  deploy-ffmpeg:
    runs-on: [self-hosted, prod-runner]
    needs: [watch, ffmpeg-build]
    if: ${{ needs.watch.outputs.ffmpeg == 'true' }}
    steps:
      - name: Checkout only docker-compose.prod.yml
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            docker-compose.prod.yml
          sparse-checkout-cone-mode: false

      - name: Copy environment file to server folder
        env:
          ENV_PROD_B64: ${{ secrets.ENV_PROD_B64 }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          set -e
          cd ~
          mkdir -p ./$TARGET_DIR
          if [ -z "$ENV_PROD_B64" ]; then
            echo "ENV_PROD_B64 is empty"
            exit 1
          fi
          echo "$ENV_PROD_B64" | base64 --decode > ~/$TARGET_DIR/.env
          chmod 600 ~/$TARGET_DIR/.env
          echo ".env created in $TARGET_DIR"

      - name: Copy compose prod into target dir
        env:
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          COMPOSE_FILE_PROD: ${{ vars.COMPOSE_FILE_PROD }}
        run: |
          cd ~
          mkdir -p ./$TARGET_DIR
          cp $COMPOSE_FILE_PROD ./$TARGET_DIR/docker-compose.yml
          ls -la ./$TARGET_DIR
          sed -n '1,200p' ./$TARGET_DIR/docker-compose.yml

      - name: Pull Image and Run Compose
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
          FFMPEG_IMAGE_NAME: ${{ secrets.DOCKER_HUB_FFMPEG_IMAGE_NAME }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          set -e
          cd ~/$TARGET_DIR
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin
          docker pull $FFMPEG_IMAGE_NAME
          docker logout
          docker compose -f docker-compose.yml up $FFMPEG_SERVICE_NAME -d

  api-build:
    name: Build, test
    runs-on: ubuntu-latest
    needs: [watch, ffmpeg-build]
    if: ${{ needs.watch.outputs.api == 'true' }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create temp .env from secret (base64)
        env:
          ENV_B64: ${{ secrets.ENV_B64 }}
        run: |
          set -e
          if [ -z "$ENV_B64" ]; then echo "ENV_B64 empty"; exit 1; fi
          echo "$ENV_B64" | base64 --decode > ./.env.dev
          chmod 600 ./.env.dev

      - name: Start docker-compose for integration tests and stop when api exits
        env:
          API_IMAGE_NAME: ${{ secrets.DOCKER_HUB_API_IMAGE_NAME }}
          FFMPEG_IMAGE_NAME: ${{ secrets.DOCKER_HUB_FFMPEG_IMAGE_NAME }}
          API_SERVICE_NAME: ${{ vars.API_SERVICE_NAME}}
          COMPOSE_FILE_DEV: ${{ vars.COMPOSE_FILE_DEV}}
        run: |
          docker build -t "$API_IMAGE_NAME" -f apps/api/Dockerfile .
          docker build -t "$FFMPEG_IMAGE_NAME" -f apps/ffmpeg/Dockerfile .
          docker compose -f $COMPOSE_FILE_DEV up -d
          chmod +x ./scripts/wait-for-docker-health.sh
          SLEEP_INTERVAL=1 MAX_RETRIES=10 STACK_FILE=$COMPOSE_FILE_DEV SERVICE_NAME=$API_SERVICE_NAME ./scripts/wait-for-docker-healthy.sh --down

      - name: Login to Docker Hub
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
        run: |
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin

      - name: Push to Registry
        env:
          API_IMAGE_NAME: ${{ secrets.DOCKER_HUB_API_IMAGE_NAME }}
        run: |
          docker push "$API_IMAGE_NAME"

      - name: Logout Docker Hub
        run: docker logout

      - name: Remove .env
        if: always()
        run: |
          rm -f ./.env.dev || true

  deploy-api:
    runs-on: [self-hosted, prod-runner]
    needs: [watch, api-build]
    if: ${{ needs.watch.outputs.api == 'true' }}
    steps:
      - name: Checkout only docker-compose.prod.yml
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            docker-compose.prod.yml
          sparse-checkout-cone-mode: false

      - name: Show the file
        env:
          COMPOSE_FILE_PROD: ${{ vars.COMPOSE_FILE_PROD }}
        run: |
          echo "File exists:"
          ls -la $COMPOSE_FILE_PROD
          sed -n '1,200p' $COMPOSE_FILE_PROD

      - name: Copy environment file to server folder
        env:
          ENV_PROD_B64: ${{ secrets.ENV_PROD_B64 }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          set -e
          cd ~
          mkdir -p ./$TARGET_DIR
          if [ -z "$ENV_PROD_B64" ]; then
            echo "ENV_PROD_B64 is empty"
            exit 1
          fi
          echo "$ENV_PROD_B64" | base64 --decode > ~/$TARGET_DIR/.env
          chmod 600 ~/$TARGET_DIR/.env
          echo ".env created in $TARGET_DIR"

      - name: Copy compose into target dir
        env:
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          COMPOSE_FILE_PROD: ${{ vars.COMPOSE_FILE_PROD }}
        run: |
          cd ~
          mkdir -p ./$TARGET_DIR
          cp $COMPOSE_FILE_PROD ./$TARGET_DIR/docker-compose.yml
          ls -la ./$TARGET_DIR
          sed -n '1,200p' ./$TARGET_DIR/docker-compose.yml

      - name: Pull Image and Run Compose (only recreate service)
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
          API_IMAGE_NAME: ${{ secrets.DOCKER_HUB_API_IMAGE_NAME }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          API_SERVICE_NAME: ${{ vars.API_SERVICE_NAME}}
        run: |
          set -e
          cd ~/$TARGET_DIR
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin
          docker pull "$API_IMAGE_NAME"
          docker logout
          docker compose -f docker-compose.yml up --no-deps $API_SERVICE_NAME -d
