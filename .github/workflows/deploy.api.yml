name: Deploy Workflow With Integration Test

on:
  push:
    branches: [alpha]
    paths:
      - 'packages/api/**'
  workflow_dispatch:

jobs:
  build-and-test:
    name: Build, test
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create temp .env from secret (base64)
        env:
          ENV_B64: ${{ secrets.ENV_B64 }}
        run: |
          set -e
          if [ -z "$ENV_B64" ]; then echo "ENV_B64 empty"; exit 1; fi
          # decode base64 into the file inside packages/api directly
          echo "$ENV_B64" | base64 --decode > packages/api/.env
          chmod 600 packages/api/.env

      - name: Start docker-compose for integration tests and stop when api exits
        run: |
          docker compose -f packages/api/docker-compose.yml up --build --abort-on-container-exit --exit-code-from api
          EXIT_CODE=$?
          docker compose -f packages/api/docker-compose.yml down --volumes --remove-orphans
          if [ $EXIT_CODE -ne 0 ]; then exit $EXIT_CODE; fi

      - name: Remove .env
        if: always()
        run: |
          rm -f packages/api/.env || true

  push-hub:
    name: Push Production Image to Hub
    runs-on: ubuntu-latest
    needs: [build-and-test]
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
        run: |
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin

      - name: Build and Push
        env:
          IMAGE_NAME: ${{ secrets.DOCKER_HUB_IMAGE_NAME }}
        run: |
          docker build -t "$IMAGE_NAME" -f packages/api/Dockerfile.prod .
          docker push "$IMAGE_NAME"

      - name: Logout Docker Hub
        run: docker logout

  deploy-on-server:
    runs-on: [self-hosted, prod-runner]
    needs: [push-hub]
    steps:
      - name: Checkout only docker-compose.prod.yml
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            packages/api/docker-compose.prod.yml
          sparse-checkout-cone-mode: false

      - name: Show the file
        run: |
          echo "File exists:"
          ls -la packages/api/docker-compose.prod.yml
          sed -n '1,200p' packages/api/docker-compose.prod.yml

      - name: Copy environment file to server folder
        env:
          ENV_PROD_B64: ${{ secrets.ENV_PROD_B64 }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          set -e
          mkdir -p "$TARGET_DIR"
          if [ -z "$ENV_PROD_B64" ]; then
            echo "ENV_PROD_B64 is empty"
            exit 1
          fi
          echo "$ENV_PROD_B64" | base64 --decode > "$TARGET_DIR/.env"
          chmod 600 "$TARGET_DIR/.env"
          echo ".env created in $TARGET_DIR"

      - name: Copy compose into target dir
        env:
          TARGET_DIR: ${{ vars.TARGET_DIR }}
        run: |
          mkdir -p "$TARGET_DIR"
          # copy and rename to docker-compose.yml in target dir
          cp packages/api/docker-compose.prod.yml "$TARGET_DIR/docker-compose.yml"
          ls -la "$TARGET_DIR"
          sed -n '1,200p' "$TARGET_DIR/docker-compose.yml"

      - name: Pull Image and Run Compose (only recreate service)
        env:
          USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
          IMAGE_NAME: ${{ secrets.DOCKER_HUB_IMAGE_NAME }}
          TARGET_DIR: ${{ vars.TARGET_DIR }}
          SERVICE_NAME: ${{ vars.SERVICE_NAME}}
        run: |
          set -e
          cd "$TARGET_DIR"
          echo "$PASSWORD" | docker login -u "$USERNAME" --password-stdin
          docker pull "$IMAGE_NAME"
          docker logout
          docker compose -f docker-compose.yml up -d --force-recreate --no-deps $SERVICE_NAME
